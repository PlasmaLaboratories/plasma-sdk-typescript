/**
 * Generated by the protoc-gen-ts.  DO NOT EDIT!
 * compiler version: 3.6.1
 * source: models/address.proto
 * git: https://github.com/thesayyn/protoc-gen-ts */
import * as dependency_1 from "./common";
import * as dependency_2 from "./verification_key";
import * as dependency_3 from "./proof";
import * as pb_1 from "google-protobuf";
export namespace co.topl.proto.models {
    export class FullAddress extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            networkPrefix?: dependency_1.co.topl.proto.models.NetworkPrefix;
            spendingAddress?: SpendingAddress;
            stakingAddress?: StakingAddress;
            commitment?: dependency_3.co.topl.proto.models.ProofKnowledgeEd25519;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("networkPrefix" in data && data.networkPrefix != undefined) {
                    this.networkPrefix = data.networkPrefix;
                }
                if ("spendingAddress" in data && data.spendingAddress != undefined) {
                    this.spendingAddress = data.spendingAddress;
                }
                if ("stakingAddress" in data && data.stakingAddress != undefined) {
                    this.stakingAddress = data.stakingAddress;
                }
                if ("commitment" in data && data.commitment != undefined) {
                    this.commitment = data.commitment;
                }
            }
        }
        get networkPrefix() {
            return pb_1.Message.getWrapperField(this, dependency_1.co.topl.proto.models.NetworkPrefix, 1) as dependency_1.co.topl.proto.models.NetworkPrefix;
        }
        set networkPrefix(value: dependency_1.co.topl.proto.models.NetworkPrefix) {
            pb_1.Message.setWrapperField(this, 1, value);
        }
        get has_networkPrefix() {
            return pb_1.Message.getField(this, 1) != null;
        }
        get spendingAddress() {
            return pb_1.Message.getWrapperField(this, SpendingAddress, 2) as SpendingAddress;
        }
        set spendingAddress(value: SpendingAddress) {
            pb_1.Message.setWrapperField(this, 2, value);
        }
        get has_spendingAddress() {
            return pb_1.Message.getField(this, 2) != null;
        }
        get stakingAddress() {
            return pb_1.Message.getWrapperField(this, StakingAddress, 3) as StakingAddress;
        }
        set stakingAddress(value: StakingAddress) {
            pb_1.Message.setWrapperField(this, 3, value);
        }
        get has_stakingAddress() {
            return pb_1.Message.getField(this, 3) != null;
        }
        get commitment() {
            return pb_1.Message.getWrapperField(this, dependency_3.co.topl.proto.models.ProofKnowledgeEd25519, 4) as dependency_3.co.topl.proto.models.ProofKnowledgeEd25519;
        }
        set commitment(value: dependency_3.co.topl.proto.models.ProofKnowledgeEd25519) {
            pb_1.Message.setWrapperField(this, 4, value);
        }
        get has_commitment() {
            return pb_1.Message.getField(this, 4) != null;
        }
        static fromObject(data: {
            networkPrefix?: ReturnType<typeof dependency_1.co.topl.proto.models.NetworkPrefix.prototype.toObject>;
            spendingAddress?: ReturnType<typeof SpendingAddress.prototype.toObject>;
            stakingAddress?: ReturnType<typeof StakingAddress.prototype.toObject>;
            commitment?: ReturnType<typeof dependency_3.co.topl.proto.models.ProofKnowledgeEd25519.prototype.toObject>;
        }): FullAddress {
            const message = new FullAddress({});
            if (data.networkPrefix != null) {
                message.networkPrefix = dependency_1.co.topl.proto.models.NetworkPrefix.fromObject(data.networkPrefix);
            }
            if (data.spendingAddress != null) {
                message.spendingAddress = SpendingAddress.fromObject(data.spendingAddress);
            }
            if (data.stakingAddress != null) {
                message.stakingAddress = StakingAddress.fromObject(data.stakingAddress);
            }
            if (data.commitment != null) {
                message.commitment = dependency_3.co.topl.proto.models.ProofKnowledgeEd25519.fromObject(data.commitment);
            }
            return message;
        }
        toObject() {
            const data: {
                networkPrefix?: ReturnType<typeof dependency_1.co.topl.proto.models.NetworkPrefix.prototype.toObject>;
                spendingAddress?: ReturnType<typeof SpendingAddress.prototype.toObject>;
                stakingAddress?: ReturnType<typeof StakingAddress.prototype.toObject>;
                commitment?: ReturnType<typeof dependency_3.co.topl.proto.models.ProofKnowledgeEd25519.prototype.toObject>;
            } = {};
            if (this.networkPrefix != null) {
                data.networkPrefix = this.networkPrefix.toObject();
            }
            if (this.spendingAddress != null) {
                data.spendingAddress = this.spendingAddress.toObject();
            }
            if (this.stakingAddress != null) {
                data.stakingAddress = this.stakingAddress.toObject();
            }
            if (this.commitment != null) {
                data.commitment = this.commitment.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.has_networkPrefix)
                writer.writeMessage(1, this.networkPrefix, () => this.networkPrefix.serialize(writer));
            if (this.has_spendingAddress)
                writer.writeMessage(2, this.spendingAddress, () => this.spendingAddress.serialize(writer));
            if (this.has_stakingAddress)
                writer.writeMessage(3, this.stakingAddress, () => this.stakingAddress.serialize(writer));
            if (this.has_commitment)
                writer.writeMessage(4, this.commitment, () => this.commitment.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): FullAddress {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new FullAddress();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.networkPrefix, () => message.networkPrefix = dependency_1.co.topl.proto.models.NetworkPrefix.deserialize(reader));
                        break;
                    case 2:
                        reader.readMessage(message.spendingAddress, () => message.spendingAddress = SpendingAddress.deserialize(reader));
                        break;
                    case 3:
                        reader.readMessage(message.stakingAddress, () => message.stakingAddress = StakingAddress.deserialize(reader));
                        break;
                    case 4:
                        reader.readMessage(message.commitment, () => message.commitment = dependency_3.co.topl.proto.models.ProofKnowledgeEd25519.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): FullAddress {
            return FullAddress.deserialize(bytes);
        }
    }
    export class SpendingAddress extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            typedEvidence?: dependency_1.co.topl.proto.models.TypedEvidence;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("typedEvidence" in data && data.typedEvidence != undefined) {
                    this.typedEvidence = data.typedEvidence;
                }
            }
        }
        get typedEvidence() {
            return pb_1.Message.getWrapperField(this, dependency_1.co.topl.proto.models.TypedEvidence, 1) as dependency_1.co.topl.proto.models.TypedEvidence;
        }
        set typedEvidence(value: dependency_1.co.topl.proto.models.TypedEvidence) {
            pb_1.Message.setWrapperField(this, 1, value);
        }
        get has_typedEvidence() {
            return pb_1.Message.getField(this, 1) != null;
        }
        static fromObject(data: {
            typedEvidence?: ReturnType<typeof dependency_1.co.topl.proto.models.TypedEvidence.prototype.toObject>;
        }): SpendingAddress {
            const message = new SpendingAddress({});
            if (data.typedEvidence != null) {
                message.typedEvidence = dependency_1.co.topl.proto.models.TypedEvidence.fromObject(data.typedEvidence);
            }
            return message;
        }
        toObject() {
            const data: {
                typedEvidence?: ReturnType<typeof dependency_1.co.topl.proto.models.TypedEvidence.prototype.toObject>;
            } = {};
            if (this.typedEvidence != null) {
                data.typedEvidence = this.typedEvidence.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.has_typedEvidence)
                writer.writeMessage(1, this.typedEvidence, () => this.typedEvidence.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): SpendingAddress {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new SpendingAddress();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.typedEvidence, () => message.typedEvidence = dependency_1.co.topl.proto.models.TypedEvidence.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): SpendingAddress {
            return SpendingAddress.deserialize(bytes);
        }
    }
    export class StakingAddress extends pb_1.Message {
        #one_of_decls: number[][] = [[1, 2]];
        constructor(data?: any[] | ({} & (({
            operator?: StakingAddressOperator;
            nonStaking?: never;
        } | {
            operator?: never;
            nonStaking?: StakingAddressNonStaking;
        })))) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("operator" in data && data.operator != undefined) {
                    this.operator = data.operator;
                }
                if ("nonStaking" in data && data.nonStaking != undefined) {
                    this.nonStaking = data.nonStaking;
                }
            }
        }
        get operator() {
            return pb_1.Message.getWrapperField(this, StakingAddressOperator, 1) as StakingAddressOperator;
        }
        set operator(value: StakingAddressOperator) {
            pb_1.Message.setOneofWrapperField(this, 1, this.#one_of_decls[0], value);
        }
        get has_operator() {
            return pb_1.Message.getField(this, 1) != null;
        }
        get nonStaking() {
            return pb_1.Message.getWrapperField(this, StakingAddressNonStaking, 2) as StakingAddressNonStaking;
        }
        set nonStaking(value: StakingAddressNonStaking) {
            pb_1.Message.setOneofWrapperField(this, 2, this.#one_of_decls[0], value);
        }
        get has_nonStaking() {
            return pb_1.Message.getField(this, 2) != null;
        }
        get sealed_value() {
            const cases: {
                [index: number]: "none" | "operator" | "nonStaking";
            } = {
                0: "none",
                1: "operator",
                2: "nonStaking"
            };
            return cases[pb_1.Message.computeOneofCase(this, [1, 2])];
        }
        static fromObject(data: {
            operator?: ReturnType<typeof StakingAddressOperator.prototype.toObject>;
            nonStaking?: ReturnType<typeof StakingAddressNonStaking.prototype.toObject>;
        }): StakingAddress {
            const message = new StakingAddress({});
            if (data.operator != null) {
                message.operator = StakingAddressOperator.fromObject(data.operator);
            }
            if (data.nonStaking != null) {
                message.nonStaking = StakingAddressNonStaking.fromObject(data.nonStaking);
            }
            return message;
        }
        toObject() {
            const data: {
                operator?: ReturnType<typeof StakingAddressOperator.prototype.toObject>;
                nonStaking?: ReturnType<typeof StakingAddressNonStaking.prototype.toObject>;
            } = {};
            if (this.operator != null) {
                data.operator = this.operator.toObject();
            }
            if (this.nonStaking != null) {
                data.nonStaking = this.nonStaking.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.has_operator)
                writer.writeMessage(1, this.operator, () => this.operator.serialize(writer));
            if (this.has_nonStaking)
                writer.writeMessage(2, this.nonStaking, () => this.nonStaking.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): StakingAddress {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new StakingAddress();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.operator, () => message.operator = StakingAddressOperator.deserialize(reader));
                        break;
                    case 2:
                        reader.readMessage(message.nonStaking, () => message.nonStaking = StakingAddressNonStaking.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): StakingAddress {
            return StakingAddress.deserialize(bytes);
        }
    }
    export class StakingAddressOperator extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            vk?: dependency_2.co.topl.proto.models.VerificationKeyEd25519;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("vk" in data && data.vk != undefined) {
                    this.vk = data.vk;
                }
            }
        }
        get vk() {
            return pb_1.Message.getWrapperField(this, dependency_2.co.topl.proto.models.VerificationKeyEd25519, 1) as dependency_2.co.topl.proto.models.VerificationKeyEd25519;
        }
        set vk(value: dependency_2.co.topl.proto.models.VerificationKeyEd25519) {
            pb_1.Message.setWrapperField(this, 1, value);
        }
        get has_vk() {
            return pb_1.Message.getField(this, 1) != null;
        }
        static fromObject(data: {
            vk?: ReturnType<typeof dependency_2.co.topl.proto.models.VerificationKeyEd25519.prototype.toObject>;
        }): StakingAddressOperator {
            const message = new StakingAddressOperator({});
            if (data.vk != null) {
                message.vk = dependency_2.co.topl.proto.models.VerificationKeyEd25519.fromObject(data.vk);
            }
            return message;
        }
        toObject() {
            const data: {
                vk?: ReturnType<typeof dependency_2.co.topl.proto.models.VerificationKeyEd25519.prototype.toObject>;
            } = {};
            if (this.vk != null) {
                data.vk = this.vk.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.has_vk)
                writer.writeMessage(1, this.vk, () => this.vk.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): StakingAddressOperator {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new StakingAddressOperator();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.vk, () => message.vk = dependency_2.co.topl.proto.models.VerificationKeyEd25519.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): StakingAddressOperator {
            return StakingAddressOperator.deserialize(bytes);
        }
    }
    export class StakingAddressNonStaking extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {}) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") { }
        }
        static fromObject(data: {}): StakingAddressNonStaking {
            const message = new StakingAddressNonStaking({});
            return message;
        }
        toObject() {
            const data: {} = {};
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): StakingAddressNonStaking {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new StakingAddressNonStaking();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): StakingAddressNonStaking {
            return StakingAddressNonStaking.deserialize(bytes);
        }
    }
}
