/**
 * Generated by the protoc-gen-ts.  DO NOT EDIT!
 * compiler version: 3.6.1
 * source: node/models/block.proto
 * git: https://github.com/thesayyn/protoc-gen-ts */
import * as dependency_1 from "./../../consensus/models/block_header";
import * as dependency_2 from "./../../brambl/models/transaction/io_transaction";
import * as dependency_3 from "./../../brambl/models/identifier";
import * as dependency_4 from "./../../validate/validate";
import * as dependency_5 from "./../../scalapb/scalapb";
import * as dependency_6 from "./../../scalapb/validate";
import * as pb_1 from "google-protobuf";
export namespace co.topl.node.models {
    export class BlockBody extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            transactionIds?: dependency_3.co.topl.brambl.models.Identifier.IoTransaction32[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("transactionIds" in data && data.transactionIds != undefined) {
                    this.transactionIds = data.transactionIds;
                }
            }
        }
        get transactionIds() {
            return pb_1.Message.getRepeatedWrapperField(this, dependency_3.co.topl.brambl.models.Identifier.IoTransaction32, 1) as dependency_3.co.topl.brambl.models.Identifier.IoTransaction32[];
        }
        set transactionIds(value: dependency_3.co.topl.brambl.models.Identifier.IoTransaction32[]) {
            pb_1.Message.setRepeatedWrapperField(this, 1, value);
        }
        static fromObject(data: {
            transactionIds?: ReturnType<typeof dependency_3.co.topl.brambl.models.Identifier.IoTransaction32.prototype.toObject>[];
        }): BlockBody {
            const message = new BlockBody({});
            if (data.transactionIds != null) {
                message.transactionIds = data.transactionIds.map(item => dependency_3.co.topl.brambl.models.Identifier.IoTransaction32.fromObject(item));
            }
            return message;
        }
        toObject() {
            const data: {
                transactionIds?: ReturnType<typeof dependency_3.co.topl.brambl.models.Identifier.IoTransaction32.prototype.toObject>[];
            } = {};
            if (this.transactionIds != null) {
                data.transactionIds = this.transactionIds.map((item: dependency_3.co.topl.brambl.models.Identifier.IoTransaction32) => item.toObject());
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.transactionIds.length)
                writer.writeRepeatedMessage(1, this.transactionIds, (item: dependency_3.co.topl.brambl.models.Identifier.IoTransaction32) => item.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): BlockBody {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new BlockBody();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.transactionIds, () => pb_1.Message.addToRepeatedWrapperField(message, 1, dependency_3.co.topl.brambl.models.Identifier.IoTransaction32.deserialize(reader), dependency_3.co.topl.brambl.models.Identifier.IoTransaction32));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): BlockBody {
            return BlockBody.deserialize(bytes);
        }
    }
    export class FullBlockBody extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            transaction?: dependency_2.co.topl.brambl.models.transaction.IoTransaction[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("transaction" in data && data.transaction != undefined) {
                    this.transaction = data.transaction;
                }
            }
        }
        get transaction() {
            return pb_1.Message.getRepeatedWrapperField(this, dependency_2.co.topl.brambl.models.transaction.IoTransaction, 1) as dependency_2.co.topl.brambl.models.transaction.IoTransaction[];
        }
        set transaction(value: dependency_2.co.topl.brambl.models.transaction.IoTransaction[]) {
            pb_1.Message.setRepeatedWrapperField(this, 1, value);
        }
        static fromObject(data: {
            transaction?: ReturnType<typeof dependency_2.co.topl.brambl.models.transaction.IoTransaction.prototype.toObject>[];
        }): FullBlockBody {
            const message = new FullBlockBody({});
            if (data.transaction != null) {
                message.transaction = data.transaction.map(item => dependency_2.co.topl.brambl.models.transaction.IoTransaction.fromObject(item));
            }
            return message;
        }
        toObject() {
            const data: {
                transaction?: ReturnType<typeof dependency_2.co.topl.brambl.models.transaction.IoTransaction.prototype.toObject>[];
            } = {};
            if (this.transaction != null) {
                data.transaction = this.transaction.map((item: dependency_2.co.topl.brambl.models.transaction.IoTransaction) => item.toObject());
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.transaction.length)
                writer.writeRepeatedMessage(1, this.transaction, (item: dependency_2.co.topl.brambl.models.transaction.IoTransaction) => item.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): FullBlockBody {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new FullBlockBody();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.transaction, () => pb_1.Message.addToRepeatedWrapperField(message, 1, dependency_2.co.topl.brambl.models.transaction.IoTransaction.deserialize(reader), dependency_2.co.topl.brambl.models.transaction.IoTransaction));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): FullBlockBody {
            return FullBlockBody.deserialize(bytes);
        }
    }
    export class Block extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            header?: dependency_1.co.topl.consensus.models.BlockHeader;
            body?: BlockBody;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("header" in data && data.header != undefined) {
                    this.header = data.header;
                }
                if ("body" in data && data.body != undefined) {
                    this.body = data.body;
                }
            }
        }
        get header() {
            return pb_1.Message.getWrapperField(this, dependency_1.co.topl.consensus.models.BlockHeader, 1) as dependency_1.co.topl.consensus.models.BlockHeader;
        }
        set header(value: dependency_1.co.topl.consensus.models.BlockHeader) {
            pb_1.Message.setWrapperField(this, 1, value);
        }
        get has_header() {
            return pb_1.Message.getField(this, 1) != null;
        }
        get body() {
            return pb_1.Message.getWrapperField(this, BlockBody, 2) as BlockBody;
        }
        set body(value: BlockBody) {
            pb_1.Message.setWrapperField(this, 2, value);
        }
        get has_body() {
            return pb_1.Message.getField(this, 2) != null;
        }
        static fromObject(data: {
            header?: ReturnType<typeof dependency_1.co.topl.consensus.models.BlockHeader.prototype.toObject>;
            body?: ReturnType<typeof BlockBody.prototype.toObject>;
        }): Block {
            const message = new Block({});
            if (data.header != null) {
                message.header = dependency_1.co.topl.consensus.models.BlockHeader.fromObject(data.header);
            }
            if (data.body != null) {
                message.body = BlockBody.fromObject(data.body);
            }
            return message;
        }
        toObject() {
            const data: {
                header?: ReturnType<typeof dependency_1.co.topl.consensus.models.BlockHeader.prototype.toObject>;
                body?: ReturnType<typeof BlockBody.prototype.toObject>;
            } = {};
            if (this.header != null) {
                data.header = this.header.toObject();
            }
            if (this.body != null) {
                data.body = this.body.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.has_header)
                writer.writeMessage(1, this.header, () => this.header.serialize(writer));
            if (this.has_body)
                writer.writeMessage(2, this.body, () => this.body.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Block {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Block();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.header, () => message.header = dependency_1.co.topl.consensus.models.BlockHeader.deserialize(reader));
                        break;
                    case 2:
                        reader.readMessage(message.body, () => message.body = BlockBody.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Block {
            return Block.deserialize(bytes);
        }
    }
    export class FullBlock extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            header?: dependency_1.co.topl.consensus.models.BlockHeader;
            fullBody?: FullBlockBody;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("header" in data && data.header != undefined) {
                    this.header = data.header;
                }
                if ("fullBody" in data && data.fullBody != undefined) {
                    this.fullBody = data.fullBody;
                }
            }
        }
        get header() {
            return pb_1.Message.getWrapperField(this, dependency_1.co.topl.consensus.models.BlockHeader, 1) as dependency_1.co.topl.consensus.models.BlockHeader;
        }
        set header(value: dependency_1.co.topl.consensus.models.BlockHeader) {
            pb_1.Message.setWrapperField(this, 1, value);
        }
        get has_header() {
            return pb_1.Message.getField(this, 1) != null;
        }
        get fullBody() {
            return pb_1.Message.getWrapperField(this, FullBlockBody, 2) as FullBlockBody;
        }
        set fullBody(value: FullBlockBody) {
            pb_1.Message.setWrapperField(this, 2, value);
        }
        get has_fullBody() {
            return pb_1.Message.getField(this, 2) != null;
        }
        static fromObject(data: {
            header?: ReturnType<typeof dependency_1.co.topl.consensus.models.BlockHeader.prototype.toObject>;
            fullBody?: ReturnType<typeof FullBlockBody.prototype.toObject>;
        }): FullBlock {
            const message = new FullBlock({});
            if (data.header != null) {
                message.header = dependency_1.co.topl.consensus.models.BlockHeader.fromObject(data.header);
            }
            if (data.fullBody != null) {
                message.fullBody = FullBlockBody.fromObject(data.fullBody);
            }
            return message;
        }
        toObject() {
            const data: {
                header?: ReturnType<typeof dependency_1.co.topl.consensus.models.BlockHeader.prototype.toObject>;
                fullBody?: ReturnType<typeof FullBlockBody.prototype.toObject>;
            } = {};
            if (this.header != null) {
                data.header = this.header.toObject();
            }
            if (this.fullBody != null) {
                data.fullBody = this.fullBody.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.has_header)
                writer.writeMessage(1, this.header, () => this.header.serialize(writer));
            if (this.has_fullBody)
                writer.writeMessage(2, this.fullBody, () => this.fullBody.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): FullBlock {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new FullBlock();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.header, () => message.header = dependency_1.co.topl.consensus.models.BlockHeader.deserialize(reader));
                        break;
                    case 2:
                        reader.readMessage(message.fullBody, () => message.fullBody = FullBlockBody.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): FullBlock {
            return FullBlock.deserialize(bytes);
        }
    }
}
